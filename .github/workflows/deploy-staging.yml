# Builds containers and pushes to GitHub Container Registry (ghcr.io).
# Deploys public-api and registry-api to Azure Container Apps (they pull from ghcr.io).
#
# Scale: Both Container Apps use min-replicas 1 so they stay on for demo; turn off
# manually when not needed (scale to 0 in Portal or via az containerapp update).
#
# Required secrets:
#   AZURE_CREDENTIALS           - Service principal for Azure (subscription/resource group)
#   AZURE_STATIC_WEB_APPS_API_TOKEN
#   DATABASE_URL                - PostgreSQL connection string for public-api (for create/secret update)
#   GHCR_PAT                    - GitHub PAT with read:packages (so Container Apps can pull from ghcr.io)
#
# Optional secrets:
#   VITE_API_BASE               - Frontend API base URL (e.g. https://<public-api-fqdn>/api)
#   CONTAINER_APPS_ENV          - Container Apps environment name (default: secai-radar-dev-env)
#
# To use ACR instead of ghcr.io, see docs/finops/USING-GHCR-INSTEAD-OF-ACR.md (revert this workflow and use ACR_NAME).
#
name: Deploy to Staging

on:
  workflow_dispatch:
  push:
    branches: [main]

env:
  AZURE_RESOURCE_GROUP: secai-radar-rg
  AZURE_LOCATION: centralus

jobs:
  deploy:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: apps/public-web/package-lock.json
      
      - name: Install and build public-web
        working-directory: apps/public-web
        env:
          # Point at public-api Container App. Set secret VITE_API_BASE if your FQDN differs.
          VITE_API_BASE: ${{ secrets.VITE_API_BASE || 'https://secai-radar-public-api.lemonriver-a8b248dc.centralus.azurecontainerapps.io/api' }}
        run: |
          npm ci
          npm run build
          cp staticwebapp.config.json dist/
      
      - name: Deploy to Azure Static Web Apps
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}
          action: "upload"
          # Upload the built output only (skip_app_build). staticwebapp.config.json is copied into dist above.
          app_location: "apps/public-web/dist"
          output_location: "."
          skip_app_build: true
      
      # Build and push to GitHub Container Registry (ghcr.io). No ACR needed.
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Build and push public-api
        uses: docker/build-push-action@v6
        with:
          context: apps/public-api
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/secai-radar-public-api:latest
      - name: Build and push registry-api
        uses: docker/build-push-action@v6
        with:
          context: apps/registry-api
          push: true
          tags: ghcr.io/${{ github.repository_owner }}/secai-radar-registry-api:latest
      
      # Deploy public-api to Azure Container Apps (pulls from ghcr.io)
      - name: Deploy public-api to Container Apps
        env:
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          GHCR_USER: ${{ github.repository_owner }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          CONTAINER_APPS_ENV: ${{ vars.CONTAINER_APPS_ENV }}
        run: |
          set -e
          APP_NAME="secai-radar-public-api"
          IMAGE="ghcr.io/${GHCR_USER}/secai-radar-public-api:latest"
          ENV_NAME="${CONTAINER_APPS_ENV:-secai-radar-dev-env}"

          SCALE_ARGS="--min-replicas 1 --max-replicas 10 --scale-rule-name http --scale-rule-type http --scale-rule-http-concurrency 10"
          if az containerapp show --name "$APP_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --output none 2>/dev/null; then
            echo "Updating existing Container App: $APP_NAME"
            az containerapp update \
              --name "$APP_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --image "$IMAGE" \
              --registry-server "ghcr.io" \
              --registry-username "$GHCR_USER" \
              --registry-password "$GHCR_PAT" \
              $SCALE_ARGS \
              --output none
            if [ -n "$DATABASE_URL" ]; then
              echo "Updating DATABASE_URL secret"
              az containerapp secret set \
                --name "$APP_NAME" \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --secrets "database-url=$DATABASE_URL" \
                --output none
              az containerapp update \
                --name "$APP_NAME" \
                --resource-group "$AZURE_RESOURCE_GROUP" \
                --set-env-vars "DATABASE_URL=secretref:database-url" \
                --output none
            fi
          else
            if [ -z "$DATABASE_URL" ]; then
              echo "::warning::DATABASE_URL secret is not set. Skipping public-api Container App create. Add Settings → Secrets → DATABASE_URL and re-run to create it."
              exit 0
            fi
            echo "Creating Container App: $APP_NAME"
            az containerapp create \
              --name "$APP_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --environment "$ENV_NAME" \
              --image "$IMAGE" \
              --target-port 8000 \
              --ingress external \
              --registry-server "ghcr.io" \
              --registry-username "$GHCR_USER" \
              --registry-password "$GHCR_PAT" \
              --secrets "database-url=$DATABASE_URL" \
              --env-vars "DATABASE_URL=secretref:database-url" \
              $SCALE_ARGS \
              --output none
          fi
          echo "Public API FQDN: $(az containerapp show --name $APP_NAME -g $AZURE_RESOURCE_GROUP --query 'properties.configuration.ingress.fqdn' -o tsv)"
      
      # Deploy registry-api to Container Apps (pulls from ghcr.io)
      - name: Deploy registry-api to Container Apps
        env:
          GHCR_PAT: ${{ secrets.GHCR_PAT }}
          GHCR_USER: ${{ github.repository_owner }}
          CONTAINER_APPS_ENV: ${{ vars.CONTAINER_APPS_ENV }}
        run: |
          set -e
          APP_NAME="secai-radar-registry-api"
          IMAGE="ghcr.io/${GHCR_USER}/secai-radar-registry-api:latest"
          ENV_NAME="${CONTAINER_APPS_ENV:-secai-radar-dev-env}"
          SCALE_ARGS="--min-replicas 1 --max-replicas 10 --scale-rule-name http --scale-rule-type http --scale-rule-http-concurrency 10"

          if az containerapp show --name "$APP_NAME" --resource-group "$AZURE_RESOURCE_GROUP" --output none 2>/dev/null; then
            echo "Updating existing Container App: $APP_NAME"
            az containerapp update \
              --name "$APP_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --image "$IMAGE" \
              --registry-server "ghcr.io" \
              --registry-username "$GHCR_USER" \
              --registry-password "$GHCR_PAT" \
              $SCALE_ARGS \
              --output none
          else
            echo "Creating Container App: $APP_NAME"
            az containerapp create \
              --name "$APP_NAME" \
              --resource-group "$AZURE_RESOURCE_GROUP" \
              --environment "$ENV_NAME" \
              --image "$IMAGE" \
              --target-port 8001 \
              --ingress external \
              --registry-server "ghcr.io" \
              --registry-username "$GHCR_USER" \
              --registry-password "$GHCR_PAT" \
              $SCALE_ARGS \
              --output none
          fi
          echo "Registry API FQDN: $(az containerapp show --name $APP_NAME -g $AZURE_RESOURCE_GROUP --query 'properties.configuration.ingress.fqdn' -o tsv)"
